<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Zone Rush 3D: Neon vs Steampunk</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Rajdhani', 'Segoe UI', sans-serif; /* 尝试用一种更有科技感的字体 */
            color: white;
            user-select: none;
        }

        /* 动态背景网格 */
        #bg-grid {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: 
                linear-gradient(rgba(0,0,0,0.9), rgba(0,0,0,0.9)),
                repeating-linear-gradient(0deg, transparent 0, transparent 49px, #1a1a1a 50px),
                repeating-linear-gradient(90deg, transparent 0, transparent 49px, #1a1a1a 50px);
            z-index: -1;
            perspective: 1000px;
        }

        /* UI 层 */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        /* 顶部 HUD */
        .hud-bar {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 15px;
            gap: 20px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .score-container {
            display: flex;
            align-items: center;
            background: rgba(0,0,0,0.6);
            border: 1px solid #444;
            padding: 5px 15px;
            border-radius: 20px;
            min-width: 150px;
            justify-content: space-between;
            backdrop-filter: blur(5px);
        }

        .team-indicator {
            width: 12px; height: 12px; border-radius: 50%; margin-right: 10px;
            box-shadow: 0 0 10px currentColor;
        }

        #timer {
            font-size: 36px;
            font-weight: 900;
            color: white;
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
            background: rgba(0,0,0,0.5);
            padding: 5px 20px;
            clip-path: polygon(10% 0, 100% 0, 90% 100%, 0% 100%);
        }

        /* 结算弹窗 */
        #game-over {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            background: rgba(10, 10, 15, 0.95);
            padding: 50px;
            border: 1px solid #333;
            text-align: center;
            display: none;
            pointer-events: auto;
            box-shadow: 0 0 100px rgba(0,0,0,0.8);
            border-radius: 10px;
            opacity: 0;
            transition: opacity 0.3s, transform 0.3s;
        }
        
        #game-over.active {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }

        h1 { margin: 0 0 20px 0; font-size: 48px; }
        
        button {
            background: transparent;
            color: white;
            border: 2px solid white;
            padding: 15px 40px;
            font-size: 18px;
            cursor: pointer;
            margin-top: 30px;
            font-weight: bold;
            transition: 0.2s;
            text-transform: uppercase;
        }
        button:hover { background: white; color: black; box-shadow: 0 0 20px white; }

        /* 简单的操作提示 */
        #controls-hint {
            position: absolute;
            bottom: 20px; left: 20px;
            color: #666;
            font-size: 12px;
        }
    </style>
</head>
<body>

    <div id="bg-grid"></div>
    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="hud-bar">
            <div class="score-container" style="border-color: #00f3ff;">
                <div class="team-indicator" style="background: #00f3ff;"></div>
                <span id="score-neon" style="color: #00f3ff; font-weight:bold;">0%</span>
            </div>
            
            <div id="timer">90</div>

            <div class="score-container" style="border-color: #ff8800;">
                <span id="score-retro" style="color: #ff8800; font-weight:bold;">0%</span>
                <div class="team-indicator" style="background: #ff8800; margin-left: 10px; margin-right: 0;"></div>
            </div>
        </div>
        <div id="controls-hint">WASD 移动 | 鼠标 瞄准/射击</div>
    </div>

    <div id="game-over">
        <h1 id="winner-text">GAME OVER</h1>
        <div id="final-score" style="font-size: 20px; color: #aaa;"></div>
        <button onclick="location.reload()">System Reboot</button>
    </div>

<script>
/**
 * 核心设置
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// 强制高DPI渲染以获得清晰度
const dpr = window.devicePixelRatio || 1;
function resize() {
    canvas.width = window.innerWidth * dpr;
    canvas.height = window.innerHeight * dpr;
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    ctx.scale(dpr, dpr);
}
window.addEventListener('resize', resize);
resize();

// 游戏常量
const WORLD_WIDTH = 2000;
const WORLD_HEIGHT = 1500;
const GAME_DURATION = 90;
const BUILDING_HEIGHT_SCALE = 0.6; // 3D拉伸系数

// 颜色定义
const COLORS = {
    neon: {
        main: '#00f3ff',
        dark: '#005f63',
        glow: 'rgba(0, 243, 255, 0.4)',
        roof: '#0a1a1f'
    },
    retro: {
        main: '#ff8800',
        dark: '#633500',
        glow: 'rgba(255, 136, 0, 0.4)',
        roof: '#261405'
    },
    neutral: {
        main: '#555555',
        dark: '#222222',
        roof: '#333333'
    }
};

// 状态
let gameState = {
    timeLeft: GAME_DURATION,
    isOver: false,
    shake: 0
};

// 输入
const input = {
    keys: {},
    mouse: { x: 0, y: 0, worldX: 0, worldY: 0, down: false }
};

window.addEventListener('keydown', e => input.keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', e => input.keys[e.key.toLowerCase()] = false);
window.addEventListener('mousemove', e => {
    input.mouse.x = e.clientX;
    input.mouse.y = e.clientY;
});
window.addEventListener('mousedown', () => input.mouse.down = true);
window.addEventListener('mouseup', () => input.mouse.down = false);

/**
 * 摄像机类：用于实现跟随和震动
 */
class Camera {
    constructor() {
        this.x = 0;
        this.y = 0;
    }
    
    follow(target) {
        // 平滑跟随
        let targetX = target.x - window.innerWidth / 2;
        let targetY = target.y - window.innerHeight / 2;
        
        // 边界限制
        targetX = Math.max(0, Math.min(targetX, WORLD_WIDTH - window.innerWidth));
        targetY = Math.max(0, Math.min(targetY, WORLD_HEIGHT - window.innerHeight));

        this.x += (targetX - this.x) * 0.1;
        this.y += (targetY - this.y) * 0.1;

        // 屏幕震动
        if (gameState.shake > 0) {
            let magnitude = gameState.shake;
            let dx = (Math.random() - 0.5) * magnitude;
            let dy = (Math.random() - 0.5) * magnitude;
            this.x += dx;
            this.y += dy;
            gameState.shake *= 0.9;
            if (gameState.shake < 0.5) gameState.shake = 0;
        }
    }
}

const camera = new Camera();

/**
 * 实体：粒子系统
 */
class Particle {
    constructor(x, y, color, type = 'spark') {
        this.x = x;
        this.y = y;
        this.color = color;
        this.life = 1.0;
        this.decay = Math.random() * 0.03 + 0.02;
        this.type = type;
        
        let speed = Math.random() * 4 + 2;
        let angle = Math.random() * Math.PI * 2;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        
        if (type === 'smoke') {
            this.vx *= 0.3;
            this.vy *= 0.3;
            this.size = Math.random() * 10 + 5;
        } else {
            this.size = Math.random() * 3 + 1;
        }
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= this.decay;
        
        if (this.type === 'smoke') {
            this.size += 0.5;
            this.y -= 1; // 烟雾上升
        } else {
            this.vx *= 0.9; // 摩擦力
            this.vy *= 0.9;
        }
    }

    draw(ctx) {
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        
        if (this.type === 'spark') {
            ctx.fillRect(this.x - camera.x, this.y - camera.y, this.size, this.size);
        } else if (this.type === 'smoke') {
            ctx.beginPath();
            ctx.arc(this.x - camera.x, this.y - camera.y, this.size, 0, Math.PI * 2);
            ctx.fill();
        }
        
        ctx.globalAlpha = 1.0;
    }
}

/**
 * 实体：建筑物 (伪3D核心)
 */
class Building {
    constructor(x, y, w, h, height) {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
        this.height = height; // 3D高度
        
        this.owner = 'neutral';
        this.captureValue = 0;
        this.maxCapture = 100;
        this.turretCooldown = 0;
        this.animOffset = Math.random() * 100;
    }

    update() {
        this.animOffset += 0.5;

        // 炮台逻辑
        if (this.owner !== 'neutral') {
            this.turretCooldown--;
            if (this.turretCooldown <= 0) {
                this.fireTurret();
                this.turretCooldown = 60; // 1秒射速
            }
        }
    }

    fireTurret() {
        let nearestDist = 500;
        let target = null;
        
        agents.forEach(a => {
            if (a.team !== this.owner && a.alive) {
                let d = Math.hypot(a.x - (this.x + this.w/2), a.y - (this.y + this.h/2));
                if (d < nearestDist) {
                    nearestDist = d;
                    target = a;
                }
            }
        });

        if (target) {
            const bx = this.x + this.w/2;
            const by = this.y + this.h/2;
            
            // 简单的3D高度修正：炮台在屋顶上，所以子弹发射点要加上视觉偏移
            // 这里为了简化碰撞，逻辑坐标依然是 ground level，但视觉上我们会画在屋顶
            const angle = Math.atan2(target.y - by, target.x - bx);
            bullets.push(new Bullet(bx, by, angle, this.owner, true));
        }
    }

    takeDamage(amount, team) {
        let dir = team === 'neon' ? 1 : -1;
        this.captureValue += dir * amount;
        
        // 限制
        if (this.captureValue > this.maxCapture) this.captureValue = this.maxCapture;
        if (this.captureValue < -this.maxCapture) this.captureValue = -this.maxCapture;

        // 判定归属
        let prevOwner = this.owner;
        if (this.captureValue >= this.maxCapture) this.owner = 'neon';
        else if (this.captureValue <= -this.maxCapture) this.owner = 'retro';
        else if (Math.abs(this.captureValue) < 30) this.owner = 'neutral';

        if (prevOwner !== this.owner && this.owner !== 'neutral') {
            // 占领特效
            gameState.shake = 10;
            for(let i=0; i<20; i++) {
                particles.push(new Particle(this.x + this.w/2, this.y + this.h/2, COLORS[this.owner].main));
            }
        }
    }

    draw(ctx) {
        // 计算伪3D投影
        // 视点中心 (屏幕中心)
        const cx = camera.x + window.innerWidth / 2;
        const cy = camera.y + window.innerHeight / 2;
        
        // 物体中心
        const ox = this.x + this.w / 2;
        const oy = this.y + this.h / 2;
        
        // 偏移量 (离中心越远，偏移越大)
        const dx = (ox - cx) * 0.02 * (this.height * 0.05);
        const dy = (oy - cy) * 0.02 * (this.height * 0.05);

        // 底部坐标 (世界坐标 - 相机坐标)
        const bx = this.x - camera.x;
        const by = this.y - camera.y;
        
        // 顶部坐标 (底部 + 偏移)
        const tx = bx + dx;
        const ty = by + dy;

        const col = COLORS[this.owner];

        // 1. 绘制阴影 (稍微偏移)
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(bx + 15, by + 15, this.w, this.h);

        // 2. 绘制侧墙 (连接底部和顶部)
        ctx.fillStyle = col.dark;
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 1;
        
        ctx.beginPath();
        ctx.moveTo(bx, by); // 左上底
        ctx.lineTo(tx, ty); // 左上顶
        ctx.lineTo(tx + this.w, ty); // 右上顶
        ctx.lineTo(bx + this.w, by); // 右上底
        ctx.fill(); ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(bx, by); // 左上底
        ctx.lineTo(tx, ty); // 左上顶
        ctx.lineTo(tx, ty + this.h); // 左下顶
        ctx.lineTo(bx, by + this.h); // 左下底
        ctx.fill(); ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(bx, by + this.h); 
        ctx.lineTo(tx, ty + this.h); 
        ctx.lineTo(tx + this.w, ty + this.h); 
        ctx.lineTo(bx + this.w, by + this.h); 
        ctx.fill(); ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(bx + this.w, by); 
        ctx.lineTo(tx + this.w, ty); 
        ctx.lineTo(tx + this.w, ty + this.h); 
        ctx.lineTo(bx + this.w, by + this.h); 
        ctx.fill(); ctx.stroke();

        // 3. 绘制屋顶
        ctx.fillStyle = col.roof;
        ctx.fillRect(tx, ty, this.w, this.h);
        
        // 屋顶描边 (发光)
        ctx.strokeStyle = col.main;
        ctx.lineWidth = 2;
        if (this.owner !== 'neutral') {
            ctx.shadowColor = col.main;
            ctx.shadowBlur = 15;
        }
        ctx.strokeRect(tx, ty, this.w, this.h);
        ctx.shadowBlur = 0; // 重置

        // 4. 屋顶细节 (风格化)
        ctx.save();
        ctx.beginPath();
        ctx.rect(tx, ty, this.w, this.h);
        ctx.clip(); // 限制绘图区域在屋顶内

        if (this.owner === 'neon') {
            // 霓虹网格
            ctx.strokeStyle = 'rgba(0, 243, 255, 0.3)';
            ctx.lineWidth = 2;
            let offset = this.animOffset % 20;
            for(let i=0; i<this.w; i+=20) {
                ctx.moveTo(tx + i + offset - 20, ty);
                ctx.lineTo(tx + i + offset - 40, ty + this.h);
            }
            ctx.stroke();
        } else if (this.owner === 'retro') {
            // 蒸汽朋克 齿轮/交叉线
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(tx, ty); ctx.lineTo(tx+this.w, ty+this.h);
            ctx.moveTo(tx+this.w, ty); ctx.lineTo(tx, ty+this.h);
            ctx.stroke();
            
            ctx.fillStyle = '#cd7f32'; // 铜色
            ctx.beginPath();
            ctx.arc(tx + this.w/2, ty + this.h/2, 10, 0, Math.PI*2);
            ctx.fill();
            ctx.stroke();
        } else {
            // 中立进度条
            let pct = this.captureValue / this.maxCapture;
            if (pct !== 0) {
                ctx.fillStyle = pct > 0 ? COLORS.neon.main : COLORS.retro.main;
                let bw = this.w * Math.abs(pct);
                ctx.fillRect(tx + (this.w - bw)/2, ty + this.h/2 - 5, bw, 10);
            }
        }
        ctx.restore();

        // 5. 炮台绘制 (如果有)
        if (this.owner !== 'neutral') {
            ctx.fillStyle = col.main;
            ctx.beginPath();
            // 炮台也有一点点高度
            let txC = tx + this.w/2;
            let tyC = ty + this.h/2;
            ctx.arc(txC, tyC - 5, 8, 0, Math.PI*2);
            ctx.fill();
        }
    }
}

/**
 * 实体：子弹
 */
class Bullet {
    constructor(x, y, angle, team, isTurret = false) {
        this.x = x;
        this.y = y;
        this.vx = Math.cos(angle) * (isTurret ? 8 : 15);
        this.vy = Math.sin(angle) * (isTurret ? 8 : 15);
        this.team = team;
        this.isTurret = isTurret;
        this.dead = false;
        this.trail = [];
    }

    update() {
        // 记录轨迹
        this.trail.push({x: this.x, y: this.y});
        if(this.trail.length > 5) this.trail.shift();

        this.x += this.vx;
        this.y += this.vy;

        // 边界移除
        if (this.x < 0 || this.x > WORLD_WIDTH || this.y < 0 || this.y > WORLD_HEIGHT) this.dead = true;

        // 碰撞：建筑
        if (!this.isTurret) {
            for (let b of buildings) {
                // 简单的矩形碰撞
                if (this.x > b.x && this.x < b.x + b.w && this.y > b.y && this.y < b.y + b.h) {
                    b.takeDamage(10, this.team);
                    this.dead = true;
                    // 撞击火花
                    for(let i=0; i<3; i++) particles.push(new Particle(this.x, this.y, COLORS[this.team].main));
                    return;
                }
            }
        } else {
            // 炮台子弹打到建筑上消失
            for (let b of buildings) {
                if (this.x > b.x && this.x < b.x + b.w && this.y > b.y && this.y < b.y + b.h) {
                    this.dead = true;
                    return;
                }
            }
        }

        // 碰撞：角色
        for (let a of agents) {
            if (a.alive && a.team !== this.team) {
                let dist = Math.hypot(this.x - a.x, this.y - a.y);
                if (dist < a.radius + 5) {
                    a.takeDamage(10);
                    this.dead = true;
                    for(let i=0; i<5; i++) particles.push(new Particle(this.x, this.y, 'red'));
                    return;
                }
            }
        }
    }

    draw(ctx) {
        ctx.strokeStyle = COLORS[this.team].main;
        ctx.lineWidth = 3;
        ctx.beginPath();
        if (this.trail.length > 0) {
            ctx.moveTo(this.trail[0].x - camera.x, this.trail[0].y - camera.y);
            for(let p of this.trail) ctx.lineTo(p.x - camera.x, p.y - camera.y);
        }
        ctx.lineTo(this.x - camera.x, this.y - camera.y);
        ctx.stroke();

        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(this.x - camera.x, this.y - camera.y, 3, 0, Math.PI*2);
        ctx.fill();
    }
}

/**
 * 实体：特工 (玩家/Bot)
 */
class Agent {
    constructor(x, y, team, isPlayer) {
        this.x = x;
        this.y = y;
        this.team = team;
        this.isPlayer = isPlayer;
        this.radius = 16;
        this.hp = 100;
        this.alive = true;
        this.respawnTimer = 0;
        this.angle = 0;
        this.shootCd = 0;
    }

    update() {
        if (!this.alive) {
            this.respawnTimer--;
            if (this.respawnTimer <= 0) {
                this.alive = true;
                this.hp = 100;
                this.x = this.team === 'neon' ? 100 : WORLD_WIDTH - 100;
                this.y = Math.random() * WORLD_HEIGHT;
            }
            return;
        }

        if (this.isPlayer) {
            // 玩家控制
            let dx = 0, dy = 0;
            if (input.keys['w']) dy = -1;
            if (input.keys['s']) dy = 1;
            if (input.keys['a']) dx = -1;
            if (input.keys['d']) dx = 1;
            
            if (dx || dy) {
                let len = Math.hypot(dx, dy);
                this.x += (dx/len) * 5;
                this.y += (dy/len) * 5;
            }

            // 计算鼠标的世界坐标
            let mx = input.mouse.x + camera.x;
            let my = input.mouse.y + camera.y;
            this.angle = Math.atan2(my - this.y, mx - this.x);

            if (input.mouse.down && this.shootCd <= 0) {
                this.shoot(this.angle);
                this.shootCd = 8;
            }

        } else {
            // 简单的Bot AI
            this.aiLogic();
        }

        if (this.shootCd > 0) this.shootCd--;

        // 碰撞与边界
        this.x = Math.max(20, Math.min(WORLD_WIDTH-20, this.x));
        this.y = Math.max(20, Math.min(WORLD_HEIGHT-20, this.y));
        
        // 建筑阻挡
        buildings.forEach(b => {
            let cx = Math.max(b.x, Math.min(this.x, b.x + b.w));
            let cy = Math.max(b.y, Math.min(this.y, b.y + b.h));
            let d2 = (this.x - cx)**2 + (this.y - cy)**2;
            if (d2 < this.radius**2) {
                let ang = Math.atan2(this.y - cy, this.x - cx);
                this.x = cx + Math.cos(ang) * (this.radius + 1);
                this.y = cy + Math.sin(ang) * (this.radius + 1);
            }
        });
    }

    aiLogic() {
        // 1. 找最近的未占领建筑或敌人
        if (!this.target || Math.random() < 0.05) {
             let targets = buildings.filter(b => b.owner !== this.team);
             if (targets.length) {
                 this.target = targets.sort((a,b) => 
                    Math.hypot(this.x-a.x, this.y-a.y) - Math.hypot(this.x-b.x, this.y-b.y)
                 )[0];
             }
        }

        if (this.target) {
            let tx = this.target.x + this.target.w/2;
            let ty = this.target.y + this.target.h/2;
            let dist = Math.hypot(tx - this.x, ty - this.y);
            this.angle = Math.atan2(ty - this.y, tx - this.x);

            if (dist > 200) {
                this.x += Math.cos(this.angle) * 3;
                this.y += Math.sin(this.angle) * 3;
            }
            
            if (dist < 400 && this.shootCd <= 0) {
                // 瞄准偏移
                let aimAngle = this.angle + (Math.random() - 0.5) * 0.5;
                this.shoot(aimAngle);
                this.shootCd = 15;
            }
        }
    }

    shoot(angle) {
        bullets.push(new Bullet(this.x, this.y, angle, this.team));
        // 后坐力效果
        this.x -= Math.cos(angle) * 2;
        this.y -= Math.sin(angle) * 2;
    }

    takeDamage(amount) {
        this.hp -= amount;
        if (this.hp <= 0) {
            this.alive = false;
            this.respawnTimer = 180;
            gameState.shake = 5;
            // 死亡爆炸
            for(let i=0; i<30; i++) particles.push(new Particle(this.x, this.y, COLORS[this.team].main));
            for(let i=0; i<10; i++) particles.push(new Particle(this.x, this.y, '#555', 'smoke'));
        }
    }

    draw(ctx) {
        if (!this.alive) return;
        
        let cx = this.x - camera.x;
        let cy = this.y - camera.y;

        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(this.angle);

        // 身体
        ctx.fillStyle = COLORS[this.team].main;
        
        // 风格化角色
        if (this.team === 'neon') {
            // 霓虹：三角形战机形状
            ctx.beginPath();
            ctx.moveTo(15, 0);
            ctx.lineTo(-10, 10);
            ctx.lineTo(-5, 0);
            ctx.lineTo(-10, -10);
            ctx.closePath();
            ctx.fill();
            // 发光
            ctx.shadowColor = COLORS[this.team].main;
            ctx.shadowBlur = 10;
            ctx.stroke();
        } else {
            // 复古：圆形坦克
            ctx.beginPath();
            ctx.arc(0, 0, 12, 0, Math.PI*2);
            ctx.fill();
            // 炮管
            ctx.fillStyle = '#333';
            ctx.fillRect(0, -4, 20, 8);
            ctx.strokeStyle = '#5c3a00';
            ctx.lineWidth = 2;
            ctx.strokeRect(-12, -12, 24, 24);
        }
        ctx.restore();

        // 血条
        ctx.fillStyle = '#333';
        ctx.fillRect(cx - 15, cy - 25, 30, 4);
        ctx.fillStyle = this.hp > 30 ? '#0f0' : '#f00';
        ctx.fillRect(cx - 15, cy - 25, 30 * (this.hp/100), 4);
        
        // 玩家标识
        if (this.isPlayer) {
            ctx.font = '12px sans-serif';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.fillText('YOU', cx, cy - 30);
        }
    }
}

/**
 * 主循环
 */
let buildings = [];
let agents = [];
let bullets = [];
let particles = [];

function init() {
    // 生成城市
    for (let i = 0; i < 20; i++) {
        let w = 80 + Math.random() * 80;
        let h = 80 + Math.random() * 80;
        let x = Math.random() * (WORLD_WIDTH - w);
        let y = Math.random() * (WORLD_HEIGHT - h);
        let height = 50 + Math.random() * 100; // 3D高度
        
        // 防止重叠 (简单版)
        let overlap = false;
        for (let b of buildings) {
            if (x < b.x + b.w + 20 && x + w + 20 > b.x &&
                y < b.y + b.h + 20 && y + h + 20 > b.y) {
                overlap = true; break;
            }
        }
        if (!overlap) buildings.push(new Building(x, y, w, h, height));
    }

    // 玩家
    let player = new Agent(200, WORLD_HEIGHT/2, 'neon', true);
    agents.push(player);
    // 队友
    agents.push(new Agent(200, WORLD_HEIGHT/2 + 100, 'neon', false));
    // 敌人
    for(let i=0; i<4; i++) {
        agents.push(new Agent(WORLD_WIDTH - 200, WORLD_HEIGHT/2 + (i*100 - 150), 'retro', false));
    }

    // 计时器
    let timerInt = setInterval(() => {
        if (!gameState.isOver) {
            gameState.timeLeft--;
            document.getElementById('timer').innerText = gameState.timeLeft;
            if (gameState.timeLeft <= 0) {
                endGame();
                clearInterval(timerInt);
            }
        }
    }, 1000);

    requestAnimationFrame(loop);
}

function endGame() {
    gameState.isOver = true;
    let scores = calculateScore();
    let modal = document.getElementById('game-over');
    let title = document.getElementById('winner-text');
    let sub = document.getElementById('final-score');
    
    modal.classList.add('active');
    
    if (scores.neon > scores.retro) {
        title.innerText = "NEON SYNDICATE WINS";
        title.style.color = COLORS.neon.main;
        title.style.textShadow = `0 0 20px ${COLORS.neon.main}`;
    } else if (scores.retro > scores.neon) {
        title.innerText = "RETRO GUILD WINS";
        title.style.color = COLORS.retro.main;
        title.style.textShadow = `0 0 20px ${COLORS.retro.main}`;
    } else {
        title.innerText = "STALEMATE";
    }
    
    sub.innerHTML = `NEON: ${scores.neon}%  |  RETRO: ${scores.retro}%`;
}

function calculateScore() {
    let total = buildings.reduce((a, b) => a + b.w*b.h, 0);
    let neon = buildings.filter(b => b.owner === 'neon').reduce((a, b) => a + b.w*b.h, 0);
    let retro = buildings.filter(b => b.owner === 'retro').reduce((a, b) => a + b.w*b.h, 0);
    
    let nPct = Math.floor(neon/total * 100);
    let rPct = Math.floor(retro/total * 100);
    
    document.getElementById('score-neon').innerText = nPct + "%";
    document.getElementById('score-retro').innerText = rPct + "%";
    
    return { neon: nPct, retro: rPct };
}

function loop() {
    if (gameState.isOver) return;

    // 清除
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // 摄像机跟随玩家
    let player = agents.find(a => a.isPlayer);
    if (player) camera.follow(player);

    // 1. 绘制地面边界
    ctx.strokeStyle = '#333';
    ctx.strokeRect(-camera.x, -camera.y, WORLD_WIDTH, WORLD_HEIGHT);

    // 2. 更新实体
    buildings.forEach(b => b.update());
    agents.forEach(a => a.update());
    bullets = bullets.filter(b => !b.dead);
    bullets.forEach(b => b.update());
    particles = particles.filter(p => p.life > 0);
    particles.forEach(p => p.update());

    // 3. 排序渲染 (为了正确的遮挡关系: Y轴排序)
    // 这是一个简单的伪3D排序技巧：y坐标大的物体应该画在y坐标小的物体前面
    let renderList = [
        ...buildings.map(b => ({type: 'building', obj: b, y: b.y + b.h})),
        ...agents.map(a => ({type: 'agent', obj: a, y: a.y})),
        ...bullets.map(b => ({type: 'bullet', obj: b, y: b.y})),
        ...particles.map(p => ({type: 'particle', obj: p, y: p.y}))
    ];

    renderList.sort((a, b) => a.y - b.y);

    // 4. 执行渲染
    renderList.forEach(item => {
        if (item.type === 'building') item.obj.draw(ctx);
        else if (item.type === 'agent') item.obj.draw(ctx);
        else if (item.type === 'bullet') item.obj.draw(ctx);
        else if (item.type === 'particle') item.obj.draw(ctx);
    });

    // 5. 更新分数UI
    calculateScore();

    requestAnimationFrame(loop);
}

init();

</script>
</body>
</html>